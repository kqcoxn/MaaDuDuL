# 自动化构建与发布工作流
# 负责跨平台编译、打包和发布MaaDuDuL项目
name: install

# 触发条件
on:
  push:
    tags:
      - "v*" # 仅在推送v开头的标签时触发（如v1.0.0）
    # 注释掉分支和路径触发，避免频繁构建
    # branches:
    #   - "**"
    # paths:
    #   - ".github/workflows/install.yml"
    #   - "assets/**"
    #   - "**.py"
  pull_request: # PR触发条件
    branches:
      - "**" # 所有分支的PR
    paths: # 仅当以下文件变更时触发
      - ".github/workflows/install.yml"
      - "assets/**"
      - "**.py"
  workflow_dispatch: # 允许手动触发

jobs:
  # 任务1: 生成版本元数据
  meta:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 获取完整的git历史，用于版本号生成

      - id: set_tag
        name: 设置版本标签
        run: |
          # 检查是否为正式发布（基于v*标签）
          is_release=${{ startsWith(github.ref, 'refs/tags/v') }}
                    
          # 尝试从git获取标签
          tag=$(git describe --tags --match "v*" ${{ github.ref }} || true)
                    
          # 如果没有找到v*标签，则从GitHub API获取最新发布版本
          if [[ $tag != v* ]]; then
            tag=$(curl -sX GET "https://api.github.com/repos/${{ github.repository }}/releases/latest" --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' | awk '/tag_name/{print $4}' FS='["!]')
            # 如果仍然没有找到，使用默认版本v0.0.0
            if [[ $tag != v* ]]; then
              tag="v0.0.0"
            fi
            # 为CI构建添加日期和commit hash
            tag=$(date "+$tag-%y%m%d-$(git rev-parse --short HEAD)")
          fi

          # 非正式发布版本添加ci标记
          if ! $($is_release) ; then
            prefix=${tag%-*-*}
            suffix=${tag#$prefix-}
            tag="$prefix-ci.$suffix"
          fi

          # 检查是否为预发布版本（包含alpha/beta/rc/dev/ci关键字）
          is_prerelease=false
          if [[ $tag =~ .*alpha.* || $tag =~ .*beta.* || $tag =~ .*rc.* || $tag =~ .*dev.* || $tag =~ .*-ci.* ]]; then
            is_prerelease=true
            echo "This is a pre-release version"
          fi

          # 输出版本信息供后续任务使用
          echo tag=$tag | tee -a $GITHUB_OUTPUT
          echo is_release=$is_release | tee -a $GITHUB_OUTPUT
          echo is_prerelease=$is_prerelease | tee -a $GITHUB_OUTPUT
    outputs:
      tag: ${{ steps.set_tag.outputs.tag }}
      is_release: ${{ steps.set_tag.outputs.is_release }}
      is_prerelease: ${{ steps.set_tag.outputs.is_prerelease }}

  # 任务2: 多平台构建与打包
  install:
    needs: meta # 依赖meta任务完成
    runs-on: ${{ matrix.runs-on }} # 根据目标平台选择运行环境
    strategy:
      matrix:
        include:
          # Windows 构建
          - os: win
            arch: x86_64
            runs-on: windows-latest
          - os: win
            arch: aarch64
            runs-on: windows-latest
          # macOS 构建
          - os: macos
            arch: x86_64
            runs-on: macos-latest
            is_macos: true
          - os: macos
            arch: aarch64
            runs-on: macos-latest
            is_macos: true
          # Linux 构建
          - os: linux
            arch: x86_64
            runs-on: ubuntu-latest
          - os: linux
            arch: aarch64
            runs-on: ubuntu-latest
      fail-fast: false # 允许部分构建失败时继续其他构建

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true # 同时检出子模块

      # 读取版本配置文件
      - name: 读取依赖版本配置
        id: versions
        shell: bash
        run: |
          # 读取versions.json并设置为环境变量
          MAA_FRAMEWORK_VERSION=$(jq -r '.MaaFramework' .github/versions.json)
          MFAA_VERSION=$(jq -r '.MFAAvalonia' .github/versions.json)
          echo "MAA_FRAMEWORK_VERSION=$MAA_FRAMEWORK_VERSION" >> $GITHUB_OUTPUT
          echo "MFAA_VERSION=$MFAA_VERSION" >> $GITHUB_OUTPUT
          echo "MaaFramework版本: $MAA_FRAMEWORK_VERSION"
          echo "MFAAvalonia版本: $MFAA_VERSION"

      # MaaFramework下载
      # - name: Download MaaFramework
      #   uses: robinraju/release-downloader@v1
      #   with:
      #     repository: MaaXYZ/MaaFramework
      #     fileName: "MAA-${{ matrix.os }}-${{ matrix.arch }}*" # 匹配对应平台的文件
      #     tag: ${{ steps.versions.outputs.MAA_FRAMEWORK_VERSION }} # 从versions.json读取版本
      #     out-file-path: "mfw_temp" # 临时输出目录
      #     extract: true # 自动解压

      # 清理MaaFramework压缩包
      # - name: Clean MaaFramework archives
      #   shell: bash
      #   run: |
      #     echo "清理MaaFramework压缩包文件..."
      #     rm -f mfw_temp/MAA-*.zip mfw_temp/MAA-*.tar.gz mfw_temp/MAA-*.7z
      #     echo "压缩包清理完成"

      # 设置Python环境
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      # 设置嵌入式Python环境（Windows）
      - name: Setup Embed Python (Windows)
        if: matrix.os == 'win'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          & ./ci/setup_embed_python.ps1

      # 设置嵌入式Python环境（macOS）
      - name: Setup Embed Python (macOS)
        if: matrix.os == 'macos'
        shell: bash
        run: |
          chmod +x ./ci/setup_embed_python.sh
          ./ci/setup_embed_python.sh

      # 设置嵌入式Python环境（Linux）
      - name: Setup Embed Python (Linux)
        if: matrix.os == 'linux'
        shell: bash
        run: |
          chmod +x ./ci/setup_embed_python.sh
          ./ci/setup_embed_python.sh

      # 合并Pipeline配置文件
      - name: Merge Pipeline
        shell: bash
        run: |
          python -u ./ci/merge_pipeline.py  # -u参数确保实时输出

      # 安装项目资源文件
      - name: Install Resource
        shell: bash
        run: |
          cd tools/
          python -m pip install -r ./requirements.txt  # 安装依赖
          python ./install.py ${{ needs.meta.outputs.tag }} ${{ matrix.os }}  # 执行安装脚本，传递平台参数
          cd ..

      # 映射MFAAvalonia的平台和架构命名
      # MFA使用不同的命名规则：macos→osx, x86_64→x64, aarch64→arm64
      - name: Set up MFAAvalonia naming
        id: mfa_naming
        shell: bash
        run: |
          # 平台命名映射
          if [ "${{ matrix.os }}" = "win" ]; then
            echo "mfa_os=win" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.os }}" = "macos" ]; then
            echo "mfa_os=osx" >> $GITHUB_OUTPUT  # macOS在MFA中称为osx
          elif [ "${{ matrix.os }}" = "linux" ]; then
            echo "mfa_os=linux" >> $GITHUB_OUTPUT
          else
            echo "mfa_os=unknown" >> $GITHUB_OUTPUT
          fi

          # 架构命名映射
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            echo "mfa_arch=x64" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.arch }}" = "aarch64" ]; then
            echo "mfa_arch=arm64" >> $GITHUB_OUTPUT
          else
            echo "mfa_arch=unknown" >> $GITHUB_OUTPUT
          fi

      # 下载MFAAvalonia GUI程序
      - name: Download MFAAvalonia
        if: steps.mfa_naming.outputs.mfa_os != 'unknown' && steps.mfa_naming.outputs.mfa_arch != 'unknown'
        id: download_mfa
        uses: robinraju/release-downloader@v1
        with:
          repository: SweetSmellFox/MFAAvalonia
          fileName: "MFAAvalonia-*-${{ steps.mfa_naming.outputs.mfa_os }}-${{ steps.mfa_naming.outputs.mfa_arch }}*"
          tag: ${{ steps.versions.outputs.MFAA_VERSION }} # 从versions.json读取版本
          out-file-path: "MFA"
          extract: true

      # 安装MFAAvalonia到install目录
      - name: Install MFAAvalonia
        shell: bash
        run: |
          rm -rf MFA/resource/base/model/ocr  # 删除MFA自带的 OCR model目录
          mkdir -p install  # 创建安装目录
          cp -r MFA/* install/  # 复制所有MFA文件
          rm -f install/MFAAvalonia-*.zip install/MFAAvalonia-*.tar.gz  # 清理下载的压缩包

          # 清理MFAA自带的deps文件夹内容
          # if [ -d "install/deps" ]; then
          #   echo "清理MFAA自带的deps目录..."
          #   rm -rf install/deps/*
          # else
          #   echo "创建deps目录..."
          #   mkdir -p install/deps
          # fi

      # 部署MaaFramework到deps目录
      # - name: Deploy MaaFramework to deps
      #   shell: bash
      #   run: |
      #     # 将下载的MaaFramework移动到deps目录
      #     if [ -d "mfw_temp" ]; then
      #       echo "将MaaFramework部署到install/deps/目录..."
      #       cp -r mfw_temp/* install/deps/
      #       echo "MaaFramework部署完成，文件列表："
      #       ls -la install/deps/
      #       rm -rf mfw_temp  # 清理临时目录
      #       echo "临时目录已清理"
      #     else
      #       echo "错误: MaaFramework临时目录(mfw_temp)不存在"
      #       exit 1
      #     fi

      # 配置descs说明文件
      - name: Install descs to Resource
        shell: bash
        run: |
          if [ -d "descs" ]; then
            mkdir -p install/Resource  # 确保Resource目录存在
            cp -r descs install/Resource/  # 复制descs到Resource下
          else
            echo "Warning: descs folder not found"
          fi

      # 替换应用图标
      - name: Replace Icon
        shell: bash
        run: |
          if [ -f "public/logo.ico" ]; then
            cp public/logo.ico install/Assets/logo.ico
          fi

      # 打包启动器（Windows平台）
      - name: Packing Launcher (Windows)
        if: matrix.os == 'win'
        working-directory: launcher
        shell: bash
        run: |
          python -m pip install pyinstaller
          # 打包为单文件exe，带图标，无控制台窗口
          pyinstaller --onefile --icon=../public/logo.ico --windowed MaaDuDuL.py
          cp dist/MaaDuDuL.exe ../install/MaaDuDuL.exe

      # 打包启动器（macOS平台）
      - name: Packing Launcher (macOS)
        if: matrix.os == 'macos'
        working-directory: launcher
        shell: bash
        run: |
          python -m pip install pyinstaller
          # macOS不使用图标和windowed参数，打包为单文件
          pyinstaller --onefile MaaDuDuL.py
          cp dist/MaaDuDuL ../install/MaaDuDuL
          chmod +x ../install/MaaDuDuL  # 添加执行权限

      # 打包启动器（Linux平台）
      - name: Packing Launcher (Linux)
        if: matrix.os == 'linux'
        working-directory: launcher
        shell: bash
        run: |
          python -m pip install pyinstaller
          # Linux打包为单文件
          pyinstaller --onefile MaaDuDuL.py
          cp dist/MaaDuDuL ../install/MaaDuDuL
          chmod +x ../install/MaaDuDuL  # 添加执行权限

      # 上传构建产物
      - uses: actions/upload-artifact@v4
        with:
          name: MaaDuDuL-${{ matrix.os }}-${{ matrix.arch }} # 以平台-架构命名
          path: "install" # 上传install目录

  # 任务3: 读取更新日志
  changelog:
    name: Read changelog
    runs-on: ubuntu-latest
    outputs:
      release_body: ${{ steps.read_changelog.outputs.content }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 直接读取Changelog.md文件内容
      - name: Read Changelog.md
        id: read_changelog
        run: |
          # 读取Changelog.md，跳过前4行，然后设置为output
          CHANGELOG_CONTENT=$(tail -n +5 assets/resource/Changelog.md)
          echo "content<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # 任务4: 发布到GitHub Releases（仅正式版本）
  release:
    if: ${{ needs.meta.outputs.is_release == 'true' }} # 仅在正式发布时执行
    needs: [meta, install, changelog] # 依赖前三个任务
    runs-on: ubuntu-latest
    steps:
      # 下载所有构建产物
      - uses: actions/download-artifact@v4
        with:
          path: assets

      # 打包所有产物为zip文件
      - name: 打包发布文件
        run: |
          cd assets
          for f in *; do
            (cd $f && zip -r ../$f-${{ needs.meta.outputs.tag }}.zip .)
          done

      # 创建GitHub Release
      - uses: softprops/action-gh-release@v2
        with:
          files: assets/* # 上传所有打包文件
          tag_name: ${{ needs.meta.outputs.tag }} # 使用版本标签
          body: ${{ needs.changelog.outputs.release_body }} # 使用生成的changelog
          draft: false # 不设为草稿
          prerelease: ${{ needs.meta.outputs.is_prerelease == 'true' }} # 标记预发布

      - name: Trigger MirrorChyanUploading
        shell: bash
        run: |
          gh workflow run --repo $GITHUB_REPOSITORY mirrorchyan_release.yml -f tag=${{ needs.meta.outputs.tag }}
          gh workflow run --repo $GITHUB_REPOSITORY mirrorchyan_release_note.yml -f tag=${{ needs.meta.outputs.tag }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
