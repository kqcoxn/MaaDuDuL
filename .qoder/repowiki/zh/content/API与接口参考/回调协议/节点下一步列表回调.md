# 节点下一步列表回调

<cite>
**本文档引用的文件**  
- [2.3-回调协议.md](file://instructions/maafw-guide/2.3-回调协议.md)
- [tasker.py](file://agent/customs/maahelper/tasker.py)
- [3.1-任务流水线协议.md](file://instructions/maafw-guide/3.1-任务流水线协议.md)
- [2.2-集成接口一览.md](file://instructions/maafw-guide/2.2-集成接口一览.md)
- [hooks.json](file://assets/resource/base/pipeline/其他/hooks.json)
</cite>

## 目录
1. [简介](#简介)
2. [节点下一步列表回调概述](#节点下一步列表回调概述)
3. [上下文环境与句柄](#上下文环境与句柄)
4. [回调数据结构详解](#回调数据结构详解)
5. [锚点机制深度解析](#锚点机制深度解析)
6. [实际应用示例](#实际应用示例)
7. [流程诊断与异常处理](#流程诊断与异常处理)
8. [结论](#结论)

## 简介
本文档全面解析 MaaFramework 中 Node.NextList 系列回调消息，涵盖 Starting、Succeeded 和 Failed 三种状态。文档深入探讨了回调机制的技术细节，包括 task_id、name、list 数组中各元素（name、jump_back、anchor）以及 focus 字段的含义和用途。重点阐述了当 anchor 为 true 时，name 作为锚点名称的特殊处理逻辑。通过 JSON 示例和代码片段，展示如何利用这些回调动态调整任务流程、实现智能路径选择以及诊断流程跳转异常问题。

## 节点下一步列表回调概述
Node.NextList 系列回调是 MaaFramework 任务执行流程中的关键通知机制，用于告知上层应用关于节点下一步执行路径的识别状态。该系列包含三种状态回调：

- **Node.NextList.Starting**：当节点开始识别其下一步可能的执行路径时触发。此回调标志着框架即将根据当前节点的配置（如 `next` 字段）来确定后续流程。
- **Node.NextList.Succeeded**：当节点成功识别出下一步节点列表时触发。此回调携带了完整的下一步执行路径信息，是流程控制的核心依据。
- **Node.NextList.Failed**：当节点识别下一步列表失败时触发。此回调通常意味着配置错误、资源缺失或逻辑异常，需要上层应用进行干预或记录。

这些回调通过统一的 `MaaEventCallback` 接口向上层应用发送，其 `details_json` 参数包含了丰富的执行上下文信息。

**Section sources**
- [2.3-回调协议.md](file://instructions/maafw-guide/2.3-回调协议.md#L125-L175)

## 上下文环境与句柄
在回调函数中，`handle` 参数是一个指向 `MaaContext*` 的句柄，它代表了当前任务执行的上下文环境。这个上下文环境是任务执行的“大脑”，封装了任务的状态、资源、控制器以及所有相关的运行时数据。

`MaaContext*` 句柄允许回调函数访问和操作当前任务的各个方面，例如：
- 查询任务的当前状态和历史。
- 获取和修改任务的资源（如图像、模型）。
- 执行额外的控制命令（如点击、滑动）。
- 动态修改任务流程（通过 `MaaContextOverrideNext` 等接口）。

这种设计使得回调函数不仅仅是被动的“监听者”，更可以成为主动的“决策者”，根据当前的执行状态做出智能响应。

**Section sources**
- [2.3-回调协议.md](file://instructions/maafw-guide/2.3-回调协议.md#L5-L18)

## 回调数据结构详解
Node.NextList 回调的 `details_json` 字段包含一个结构化的 JSON 对象，其核心字段如下：

```json
{
    "task_id": 12345,
    "name": "NodeA",
    "list": [
        {
            "name": "NodeB",
            "jump_back": false,
            "anchor": false
        },
        {
            "name": "NodeC",
            "jump_back": true,
            "anchor": false
        },
        {
            "name": "LastHandler",
            "jump_back": false,
            "anchor": true
        }
    ],
    "focus": "自定义通知信息"
}
```

- **task_id**: 任务 ID，一个唯一的数字标识符，用于区分不同的任务实例。
- **name**: 当前节点的名称，字符串类型，标识了正在处理的节点。
- **list**: 一个对象数组，代表了下一步可能执行的节点列表。数组中的每个元素包含：
  - **name**: 节点名称或锚点名称，字符串类型。
  - **jump_back**: 布尔值，表示是否为“回跳”操作。若为 `true`，表示流程将回退到之前的某个节点。
  - **anchor**: 布尔值，表示 `name` 字段是否为一个锚点引用。若为 `true`，则 `name` 是一个锚点名称，而非直接的节点名。
- **focus**: 焦点相关数据，可以是任意类型（字符串、对象等），常用于在 UI 上显示自定义的提示信息。

**Section sources**
- [2.3-回调协议.md](file://instructions/maafw-guide/2.3-回调协议.md#L133-L167)

## 铿点机制深度解析
锚点（Anchor）机制是 MaaFramework 实现动态流程控制的核心特性。当 `list` 数组中某个元素的 `anchor` 字段为 `true` 时，其 `name` 字段将被视为一个**锚点名称**，而不是一个直接的节点名称。

### 锚点的工作原理
1.  **设置锚点**：在任务流程的某个节点中，通过设置 `anchor` 字段来“标记”该节点。例如，节点 `A` 设置 `"anchor": "X"`，表示当执行到节点 `A` 时，会将锚点 `X` 指向节点 `A`。
2.  **引用锚点**：在后续的 `next` 或 `on_error` 列表中，可以通过 `"[Anchor]X"` 或 `{ "name": "X", "anchor": true }` 的形式来引用锚点 `X`。
3.  **运行时解析**：当流程执行到引用锚点的节点时，框架会查找**最后被设置**的锚点 `X` 所指向的节点，并跳转到该节点继续执行。

### 技术实现
在 `tasker.py` 的 `run` 方法中，可以看到框架如何处理 `next` 列表。代码会检查 `next` 字段，并将其标准化为列表。更重要的是，框架会自动注入一个名为 `_run_task_monitor_inject` 的监测节点到 `next` 列表的开头，以确保任务执行过程可被监控。这表明框架在执行流程前会动态修改和增强 `next` 列表。

```mermaid
flowchart TD
A[节点A] --> |设置锚点| AnchorX["锚点X = 节点A"]
B[节点B] --> |设置锚点| AnchorX["锚点X = 节点B"]
C[节点C] --> |next: [D, [Anchor]X]| CheckAnchor{解析锚点X}
CheckAnchor --> |最后设置为节点B| B
C --> D[节点D]
```

**Diagram sources**
- [3.1-任务流水线协议.md](file://instructions/maafw-guide/3.1-任务流水线协议.md#L1271-L1314)
- [tasker.py](file://agent/customs/maahelper/tasker.py#L64-L91)
- [hooks.json](file://assets/resource/base/pipeline/其他/hooks.json#L1-L8)

**Section sources**
- [3.1-任务流水线协议.md](file://instructions/maafw-guide/3.1-任务流水线协议.md#L1271-L1314)
- [2.2-集成接口一览.md](file://instructions/maafw-guide/2.2-集成接口一览.md#L715-L721)

## 实际应用示例
以下是一个利用锚点机制实现智能路径选择的 JSON 配置示例：

```json
{
    "日常任务入口": {
        "next": ["领取邮件", "领取奖励", "采购"]
    },
    "领取邮件": {
        "anchor": "LAST_DAILY_TASK",
        "next": ["领取奖励"]
    },
    "领取奖励": {
        "anchor": "LAST_DAILY_TASK",
        "next": ["采购"]
    },
    "采购": {
        "anchor": "LAST_DAILY_TASK",
        "next": ["回到主界面"]
    },
    "回到主界面": {
        "next": [
            "启动游戏",
            "[Anchor]LAST_DAILY_TASK"
        ]
    }
}
```

在这个例子中：
1.  无论用户执行了“领取邮件”、“领取奖励”还是“采购”中的哪一个，`LAST_DAILY_TASK` 锚点都会被更新为最后执行的那个节点。
2.  当任务需要“回到主界面”后重新开始时，`[Anchor]LAST_DAILY_TASK` 会确保流程跳转回**最后完成的日常任务**，从而实现无缝的连续作战。

## 流程诊断与异常处理
Node.NextList.Failed 回调是诊断流程跳转异常的关键。当此回调被触发时，应立即检查以下方面：
1.  **配置文件**：检查 `next` 列表中引用的节点名称是否拼写正确，是否存在。
2.  **资源完整性**：确保所有被引用的节点所依赖的资源（如图片、模型）都已正确加载。
3.  **逻辑循环**：避免因错误的 `jump_back` 或锚点引用导致无限循环。

通过监听 `Node.NextList.Succeeded` 回调，可以记录实际的执行路径，用于生成执行日志或进行性能分析。

**Section sources**
- [2.3-回调协议.md](file://instructions/maafw-guide/2.3-回调协议.md#L172-L174)

## 结论
Node.NextList 系列回调为 MaaFramework 提供了强大的流程控制能力。通过深入理解 `task_id`、`name`、`list` 数组及 `anchor` 机制，开发者可以构建出高度灵活和智能的自动化任务。锚点机制尤其强大，它允许任务流程根据运行时状态动态调整，实现了从“静态脚本”到“动态决策”的飞跃。合理利用这些回调，不仅能提升任务的鲁棒性，还能实现复杂的业务逻辑和智能的路径规划。